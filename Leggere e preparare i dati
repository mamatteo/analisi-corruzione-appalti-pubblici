---
title: "Leggere e preparare i dati"
output:
  html_document: default
  pdf_document: default
  word_document: default
subtitle: From _raw data_ to _technically correct data_
css: css/mycss.css
---

<hr>
L'analisi dei **contratti pubblici nazionali**, è dedicata alla lettura dei dati, alla loro pulizia e al loro ordinamento in modo che essi siano più facilmente analizzabili nelle fasi successive. 

Divideremo queste attività in due fasi: nella prima fase ci preoccuperemo di modellare i dati in modo da ottenere dati _tecnicamente corretti_. Nella seconda fase invece ci occuepremo di modellare i dati in modo da ottenere _dati consistenti_. 
<br><br>
In questa fase, ci occuperemo di:

1. importare i vari _dataset_ in nostro possesso, accertandoci del loro formato;
2. aggiungere un _header_ opportuno a ciascun dataset ed esplorare la struttura generale di ciascuno;
3. controllare ed eventualmente correggere i _tipi di dato_ di ciascuna colonna;
3. effettuare delle operazioni di _data cleaning_ sui dati; 
4. partizionare i _dataset_ in diverse tabelle, secondo lo schema entità-relazione progettato;

<hr>

Pulizia preventiva dell'ambiente di lavoro
```{r clean, message=FALSE, warning=FALSE, results='hide'}
rm(list = ls(all.names = TRUE)) # Pulizia degli oggetti creati 
gc() # Pulizia della memoria RAM
```

*Import* delle librerie utili al codice:
```{r setup, message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(tibble)
library(tidyverse)
library(editrules)
```
<br>

## Importare i dati 
Importiamo il dataset in formato `.csv` con la funzione `read.csv`.   

I dati memorizzati nei file `.csv` hanno come carattere separatore il punto e virgola (`;`) e sono privi di intestazione (da cui il comando `header = FALSE`), che viene fornita come materiale di supporto a parte. 
Ci preoccuperemo di riempire eventuali celle vuote con l'attributo `NA`, tramite il comando `na.strings = ""`, un'operazione semplice ma fondamentale per assicurare l'integrità dei dataset.

```{r import, include=TRUE}
path_ds_appalti = "/Users/matteo/Desktop/Analisi dati in R/01_Leggere e preparare i dati/dataset/2015/Appalti2015.csv"
path_ds_oggettogare = "/Users/matteo/Desktop/Analisi dati in R/01_Leggere e preparare i dati/dataset/2015/Oggettigare2015.csv" 
path_ds_cigcup = "/Users/matteo/Desktop/Analisi dati in R/01_Leggere e preparare i dati/dataset/2015/CigCup2015.csv"
path_ds_aggiudicatari = "/Users/matteo/Desktop/Analisi dati in R/01_Leggere e preparare i dati/dataset/2015/Aggiudicatari2015.csv"

ds_appalti <- read.csv(file = path_ds_appalti, header = FALSE, sep = ";", na.strings = "", stringsAsFactors=FALSE)
ds_oggettogare <- read.csv(file = path_ds_oggettogare, header = FALSE, sep = ";", na.strings = "", stringsAsFactors=FALSE)
ds_cigcup <- read.csv(file = path_ds_cigcup, header = FALSE, sep = ";", na.strings = "", stringsAsFactors=FALSE)
ds_aggiudicatari <- read.csv(file = path_ds_aggiudicatari, header = FALSE, sep = ";", na.strings = "", stringsAsFactors=FALSE)
```

<br>
Interroghiamo col comando `class` i quattro _dataset_ importati, per assicurarci che appartengano alla classe `dataframe`. 

Un _dataframe_ è una struttura dati adatta a dati in formato tabellare, in grado di memorizzare dati con _type value_ differenti. Proprio per questo motivo un _dataframe_ si differenzia dalle matrici, anch'esse predisposte per memorizzare dati in formato tabellare, a patto che siano però dello stesso tipo.

```{r type, include=TRUE}
class(ds_appalti)
class(ds_oggettogare) 
class(ds_cigcup)
class(ds_aggiudicatari)
```

<br>
I dati memorizzati in un _dataframe_ diventano facilmente manipolabili da specifiche funzioni di R. Uno dei comandi maggiormente utilizzati sui _dataframe_ è il comando `head()`, che ci restituisce le prime osservazioni (le prime righe) del nostro dataset. 

Proviamo allora a usare `head()` sul _dataset_ `ds_appalti`.
```{r head appalti, include=TRUE}
head(ds_appalti)
```

<br>
Grazie al comando `head()` osserviamo l'assenza di intestazione del _dataset_ preso in esame.
Procederemo quindi ad aggiungere l'intestazione a ciascuno dei quattro _dataset_ importati. 

## Aggiungere un header
```{r header}
colnames(ds_appalti) <- c("CFAmmne","NomeAmmne","IDCentroCosto", "NomeCentroCosto", "DataPubblicazione", "DataScadenzaOfferta", "NumeroGara", "Cig", "CIGAccordoQuadro", "CPV", "DescrizioneCPV", "ImportoComplessivoGara", "NrLottoComponenti", "ImportoLotto", "CodiceSceltaContraente", "TipoSceltaContraente", "CodiceModalitaRealizzazione", "ModalitaRealizzazione", "CodicePrincipaleContratto", "OggettoPrincipaleContratto", "LuogoIstat", "LuogoNuts", "FlagEscluso", "MotivoEsclusione", "CodiceEsito", "Esito", "DataAggiudicazioneDefinitiva", "CriterioDiAggiudicazione", "ImportoDiAggiudicazione", "NumeroImpreseOfferenti", "RibassoAggiudicazione", "QeBaseImportoLavori", "QeBaseImportoServizi", "QeBaseImportoForniture", "QeBaseImportoSicurezza", "QeBaseUlterioriOneriNoRibasso", "QeBaseImportoProgettazione", "QeBaseSommeADisposizione", "DataStipulaContratto", "DataInizioEffettiva", "DataTermineContrattuale", "QeFineImportoLavori", "QeFineImportoServizi", "QeFineImportoForniture", "QeFineImportoSicurezza", "QeFineImportoProgettazione", "QeFineSommeADisposizione", "DataEffettivaUltimazione")

colnames(ds_oggettogare) <- c("NumeroGara", "OggettoGara", "Cig", "OggettoLotto")

colnames(ds_cigcup) <- c("Cig", "Cup")
    
colnames(ds_aggiudicatari) <- c("Cig", "CodiceFiscale", "DenominazioneAggiudicatario", "TipoAggiudicatario", "CodiceRuolo", "Ruolo", "CodiceGruppo", "FlagAggiudicatario")
```

<br>
Utilizziamo ora il comando `str`, per esplorare la struttura dei quattro _dataset_, opportunamente intestati.
```{r str, include=TRUE}
str(ds_appalti)
str(ds_oggettogare)
str(ds_cigcup)
str(ds_aggiudicatari)
```

<br>
Con il comando `str` e l'aggiunta delle intestazioni ai quattro _dataset_, possiamo farci una prima idea delle loro dimensioni, in termini di numero di _variabili coinvolte_ (distribuite lungo le colonne) e numero di _osservazioni raccolte_ (distribuite lungo le righe). 

La lettura dell'output restituito dal comando `str`, ci aiuta anche a controllare i tipi di dato di ciascuna colonna. Scopriamo così l'esistenza di diversi casi in cui il tipo di dato assegnato _by default_ da R, non è corretto. Provvederemo quindi alla sua correzione.

## Type checking
Analizzando i _tipe value_ delle variabili nei quattro _data frame_, ci accorgiamo che non tutte possiedono il tipo di dato corretto. Procediamo pertanto a sistemare i tipi.

Correzione dei _tipi_ per il dataset `ds_appalti`.

```{r check datetype appalti, warning=FALSE}
#ds_appalti$DataPubblicazione <- as.Date(ds_appalti$DataPubblicazione)
ds_appalti$DataScadenzaOfferta <- as.Date(ds_appalti$DataScadenzaOfferta)
ds_appalti$DataAggiudicazioneDefinitiva <- as.Date(ds_appalti$DataAggiudicazioneDefinitiva)
#ds_appalti$DataStipulaContratto <- as.Date(ds_appalti$DataStipulaContratto)
#ds_appalti$DataInizioEffettiva <- as.Date(ds_appalti$DataStipulaContratto)
#ds_appalti$DataTermineContrattuale <- as.Date(ds_appalti$DataStipulaContratto)
ds_appalti$DataEffettivaUltimazione <- as.Date(ds_appalti$DataEffettivaUltimazione, format = "%y%d%m")

ds_appalti$NrLottoComponenti <- as.integer(ds_appalti$NrLottoComponenti)
ds_appalti$CodiceSceltaContraente <- as.integer(ds_appalti$CodiceSceltaContraente)
ds_appalti$CodiceModalitaRealizzazione <- as.integer(ds_appalti$CodiceModalitaRealizzazione)
ds_appalti$LuogoIstat <- as.integer(ds_appalti$LuogoIstat)
ds_appalti$CodiceEsito <- as.integer(ds_appalti$CodiceEsito)
ds_appalti$NumeroImpreseOfferenti <- as.integer(ds_appalti$NumeroImpreseOfferenti)

ds_appalti$ImportoComplessivoGara <- as.numeric(ds_appalti$ImportoComplessivoGara)
ds_appalti$ImportoDiAggiudicazione <- as.numeric(ds_appalti$ImportoDiAggiudicazione)
ds_appalti$RibassoAggiudicazione <- as.numeric(ds_appalti$RibassoAggiudicazione)
ds_appalti$QeBaseImportoServizi <- as.numeric(ds_appalti$QeBaseImportoServizi)
ds_appalti$QeBaseImportoLavori <- as.numeric(ds_appalti$QeBaseImportoLavori)
ds_appalti$QeBaseImportoForniture <- as.numeric(ds_appalti$QeBaseImportoForniture)
ds_appalti$QeBaseImportoSicurezza <- as.numeric(ds_appalti$QeBaseImportoSicurezza)
ds_appalti$QeBaseSommeADisposizione <- as.numeric(ds_appalti$QeBaseSommeADisposizione)
ds_appalti$QeFineImportoLavori <- as.numeric(ds_appalti$QeFineImportoLavori)
ds_appalti$QeFineImportoServizi <- as.numeric(ds_appalti$QeFineImportoServizi)
ds_appalti$QeFineImportoForniture <- as.numeric(ds_appalti$QeFineImportoForniture)
ds_appalti$QeFineImportoSicurezza <- as.numeric(ds_appalti$QeFineImportoSicurezza)
ds_appalti$QeFineImportoProgettazione <- as.numeric(ds_appalti$QeFineImportoProgettazione)
ds_appalti$QeFineSommeADisposizione <- as.numeric(ds_appalti$QeFineSommeADisposizione)
```

Correzione dei _tipi_ per il dataset `ds_oggettogare`
```{r check datetype oggetti delle gare}
ds_oggettogare$NumeroGara <- as.integer(ds_oggettogare$NumeroGara)
```

<br>
Normalizzazione dei campi di testo del dataset `ds_appalti`. 

Decidiamo di portare tutti i campi di testo in _minuscolo_, non solo per normalizzare i campi, ma anche per facilitare eventuali analisi di _pattern matching_ successive (ad esempio con le funzioni `grep` e `grepl`), che in R sono _case sensitive by default_. La sensibilità di queste funzioni al maiuscolo o al minuscolo si può aggirare in vari modi (ad esempio col comando `ignore.case = TRUE`), tuttavia attraverso questa normalizzazione eliminiamo da subito il problema.
```{r normalizzazione ds_appalti, include=TRUE}
ds_appalti$DescrizioneCPV <- tolower(ds_appalti$DescrizioneCPV)
ds_appalti$OggettoPrincipaleContratto <- tolower(ds_appalti$OggettoPrincipaleContratto)
ds_appalti$NomeAmmne <-  tolower(ds_appalti$NomeAmmne)
ds_appalti$NomeCentroCosto <-  tolower(ds_appalti$NomeCentroCosto)

ds_aggiudicatari$DenominazioneAggiudicatario <- tolower(ds_aggiudicatari$DenominazioneAggiudicatario)

ds_oggettogare$OggettoGara <- tolower(ds_oggettogare$OggettoGara )
```

<br>
Controlliamo a questo punto che i tipi di dato delle variabili siano corretti:
```{r check datetype quattro dataset}
glimpse(ds_appalti)
glimpse(ds_oggettogare)
glimpse(ds_cigcup)
glimpse(ds_aggiudicatari)
```

```{r estrazione NA}
# Cancellazione righe che presentano il valore "NA" su tutte le colonne
ds_appalti <- ds_appalti[rowSums(is.na(ds_appalti)) != ncol(ds_appalti), ]
ds_oggettogare <- ds_oggettogare[rowSums(is.na(ds_oggettogare)) != ncol(ds_oggettogare), ]
ds_cigcup <- ds_cigcup[rowSums(is.na(ds_cigcup)) != ncol(ds_cigcup), ]
ds_aggiudicatari <- ds_aggiudicatari[rowSums(is.na(ds_aggiudicatari)) != ncol(ds_aggiudicatari), ]
```

## Creiamo nuove tabelle

Tabella *"Amministrazioni"*
```{r create table amminsitrazioni}
if(nrow(ds_appalti) == sum(!is.na(ds_appalti$CFAmmne))){
print("Controllo superato. Ogni riga di 'ds_appalti' possiede un codice fiscale")
} else {
print("Il controllo ha avuto esito negativo. Ci sono righe senza codice fiscale")
print("Si procede all'eliminazione delle righe senza codice fiscale")
ds_appalti_cf_ok <- ds_appalti %>% drop_na(ds_appalti$CFAmmne)
}

#Creazione della tabella amministrazioni
tab_amministrazioni <- ds_appalti %>% select(CFAmmne, NomeAmmne, IDCentroCosto, NomeCentroCosto, Cig)
```

Tabella *"Gare d'appalto"*
```{r create table gare}

#Verifica di quanti CIG ci sono in ds_appalti
ds = ds_appalti
# Il numero di CIG deve corrispondere al numero di righe del datataset. 
# Non ci devono essere valori mancanti. Nel caso vanno eliminati.
if(nrow(ds) == sum(!is.na(ds$Cig))){
print("Controllo superato. Ogni riga possiede un CIG")
  print(paste0("Il numero di CIG della tabella di input è pari a ",nrow(ds)))
  ds_appalti_cig_ok = ds
} else {
print("Il controllo ha avuto esito negativo. Ci sono righe senza CIG")
print("Si procede all'eliminazione delle righe senza CIG")
ds_complete <- ds %>% drop_na(Cig)
print(paste0("Le righe iniziali erano pari a ",nrow(ds)))
print(paste0("Le righe senza CIG sono pari a ",(nrow(ds)-nrow(ds_complete))))
Sys.sleep(2)
cat("\n")
print("Rimozione delle righe prive di CIG...")
print("Costruzione del nuovo dataset...")
ds_appalti_cig_ok = ds_complete
Sys.sleep(2)
cat("\n")
print("Processo terminato!")
print("Il nuovo dataset contiene solo righe il cui CIG è presente")
cat("\n")
print("I dati sono stati salvati nel nuovo dataset 'ds_appalti_cig_ok'")
}

#Verifica di quanti CIG ci sono in ds_cigcup
ds = ds_cigcup
# Il numero di CIG deve corrispondere al numero di righe del datataset. 
# Non ci devono essere valori mancanti. Nel caso vanno eliminati.
if(nrow(ds) == sum(!is.na(ds$Cig))){
print("Controllo superato. Ogni riga possiede un CIG")
  print(paste0("Il numero di CIG della tabella di input è pari a ",nrow(ds)))
  ds_cigcup_cig_ok = ds
} else {
print("Il controllo ha avuto esito negativo. Ci sono righe senza CIG")
print("Si procede all'eliminazione delle righe senza CIG")
ds_complete <- ds %>% drop_na(Cig)
print(paste0("Le righe iniziali erano pari a ",nrow(ds)))
print(paste0("Le righe senza CIG sono pari a ",(nrow(ds)-nrow(ds_complete))))
Sys.sleep(2)
cat("\n")
print("Rimozione delle righe prive di CIG...")
print("Costruzione del nuovo dataset...")
ds_cigcup_cig_ok = ds_complete
Sys.sleep(2)
cat("\n")
print("Processo terminato!")
print("Il nuovo dataset contiene solo righe il cui CIG è presente")
cat("\n")
print("I dati sono stati salvati nel nuovo dataset 'ds_cigcup_cig_ok'")
}

#Verifica di quanti CIG ci sono in ds_oggettogare
ds = ds_oggettogare
# Il numero di CIG deve corrispondere al numero di righe del datataset. 
# Non ci devono essere valori mancanti. Nel caso vanno eliminati.
if(nrow(ds) == sum(!is.na(ds$Cig))){
print("Controllo superato. Ogni riga possiede un CIG")
  print(paste0("Il numero di CIG della tabella di input è pari a ",nrow(ds)))
  ds_oggettogare_cig_ok = ds
} else {
print("Il controllo ha avuto esito negativo. Ci sono righe senza CIG")
print("Si procede all'eliminazione delle righe senza CIG")
ds_complete <- ds %>% drop_na(Cig)
print(paste0("Le righe iniziali erano pari a ",nrow(ds)))
print(paste0("Le righe senza CIG sono pari a ",(nrow(ds)-nrow(ds_complete))))
Sys.sleep(2)
cat("\n")
print("Rimozione delle righe prive di CIG...")
print("Costruzione del nuovo dataset...")
ds_oggettogare_cig_ok = ds_complete
Sys.sleep(2)
cat("\n")
print("Processo terminato!")
print("Il nuovo dataset contiene solo righe il cui CIG è presente")
cat("\n")
print("I dati sono stati salvati nel nuovo dataset 'ds_oggettogare_cig_ok'")
}

# Eliminazione dei duplicati del dataset "ds_appalti_cig_ok" ("ds_appalti" privo di CIG mancanti)
appalti_con_cig_unico <- ds_appalti_cig_ok[!duplicated(ds_appalti_cig_ok$Cig), ] 

# Eliminazione dei duplicati del dataset "ds_cigcup_cig_ok" ("ds_cigcup" privo di CIG mancanti)
cigcup_con_cig_unico <- ds_cigcup_cig_ok[!duplicated(ds_cigcup_cig_ok$Cig), ] 

# Eliminazione dei duplicati del dataset "ds_oggettogare_cig_ok" ("ds_oggettogare" privo di CIG mancanti)
oggettogare_con_cig_unico <- ds_oggettogare_cig_ok[!duplicated(ds_oggettogare_cig_ok$Cig), ] 

#Costruzione "tabella gare d'appalto"
temptab_gare1 <- appalti_con_cig_unico %>% select(NumeroGara, Cig, CIGAccordoQuadro, CPV, DescrizioneCPV, ImportoComplessivoGara, NrLottoComponenti, ImportoLotto, CodiceSceltaContraente, TipoSceltaContraente, DataPubblicazione, DataScadenzaOfferta, CFAmmne, CodiceEsito, Esito, DataAggiudicazioneDefinitiva, CriterioDiAggiudicazione, ImportoDiAggiudicazione, NumeroImpreseOfferenti, RibassoAggiudicazione, CodiceModalitaRealizzazione, ModalitaRealizzazione)

temptab_gare2 <- oggettogare_con_cig_unico %>% select(Cig, OggettoGara, OggettoLotto)

tab_gare <- merge(x=temptab_gare1, y=temptab_gare2, by="Cig", all.x=TRUE)

```

Tabella *"Aggiudicatari"*
```{r create table aggiudicatari}
tab_aggiudicatari <- ds_aggiudicatari %>% select(DenominazioneAggiudicatario, CodiceFiscale, DenominazioneAggiudicatario, TipoAggiudicatario, CodiceRuolo, Ruolo, CodiceGruppo, FlagAggiudicatario, Cig)
tab_aggiudicatari
```

## Salviamo le tabelle in file `.csv`

Creazione del file `amminsitrazioni.csv`
```{r save table amministrazioni, gare and aggiudicatari}
write.csv2(tab_amministrazioni,'/Users/matteo/Desktop/Analisi dati in R/02_Analisi esplorativa dei dati/Tabelle di input/tab_amministrazioni.csv', row.names=FALSE)
write.csv2(tab_gare,'/Users/matteo/Desktop/Analisi dati in R/02_Analisi esplorativa dei dati/Tabelle di input/tab_gare.csv', row.names=FALSE)
write.csv2(tab_aggiudicatari,'/Users/matteo/Desktop/Analisi dati in R/02_Analisi esplorativa dei dati/Tabelle di input/tab_aggiudicatari.csv', row.names=FALSE)
```


<br><br>
<hr>
<b>Leggere e preparare i dati</b> | <i>Data cleaning</i><br>
Prima fase dell'analisi dei contratti pubblici nazionali | Matteo Troìa
<hr>
